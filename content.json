{"meta":{"title":"XiaoRong","subtitle":"","description":"","author":"XiaoRong","url":"https://linzai745.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2021-02-24T06:18:05.008Z","comments":true,"path":"404.html","permalink":"https://linzai745.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2020-10-20T05:17:14.000Z","updated":"2021-02-24T06:18:05.008Z","comments":true,"path":"about/index.html","permalink":"https://linzai745.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-20T05:14:53.000Z","updated":"2021-02-24T06:18:05.008Z","comments":true,"path":"categories/index.html","permalink":"https://linzai745.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-20T05:16:46.000Z","updated":"2021-02-24T06:18:05.008Z","comments":true,"path":"tags/index.html","permalink":"https://linzai745.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL-存储引擎","slug":"mysql/storage_engine/storage_engine","date":"2020-07-07T03:26:42.000Z","updated":"2021-03-10T08:42:32.939Z","comments":true,"path":"2020/07/07/mysql/storage-engine/storage-engine/","link":"","permalink":"https://linzai745.github.io/2020/07/07/mysql/storage-engine/storage-engine/","excerpt":"","text":"1 存储引擎1.1 相关指令 查看MySQL所提供的存储引擎 show engines; 执行结果： 查看MySQL当前默认的存储引擎 show variables like '%storage_engine%'; 执行结果： 查看表的存储引擎 show table status like \"table_name\"; 执行结果： 1.2 MyISAM存储引擎在MySQL 5.5之前，MyISAM是默认的存储引擎。MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 特性： 全文检索 压缩 空间函数(GIS) 表级锁 存储MyISAM将表存储在两个文件中：数据文件和索引文件。 文件类型 后缀名 数据文件 .MYD 索引文件 .MYI MyISAM表包含两种类型的行：动态行和静态行(长度固定)。 表修复执行表的修复可能导致一些数据的丢失，而且修复操作是非常慢的。 CHECK TABLE table_name; # 检查表的错误 REPAIR TABLE table_name; # 修复表 myisamchk； # MySQL服务器已经关闭，通过这个命令进行检查和修复操作 压缩表适合压缩的表：表在创建并导入数据以后，不会再进行修改操作。压缩表是不能进行修改的（除非先将表接触压缩，修改数据，然后再次压缩）。压缩表可以极大的减少磁盘空间的占用，因此也可以减少磁盘I/O，从而提升查询性能。压缩表也支持索引，但索引也是只读的。压缩指令： myisampack -b -f xxx.MYI 全文索引MyISAM的全文索引是一类特殊的B-Tree的索引，共有两层。 第一层是所有的关键字 第二层包含的是一组相关的“文档指针” 全文索引不会索引文档对象中的所有词语，它会根据如下规则过滤一些词语： 停用词列表中的词都不会被索引。默认的停用词根据通用的英语的使用来设置，可以使用参数ft_stopword_file指定一组外部文件来使用自定义的停用词。 对于长度大于ft_min_word_len的词语和长度小于ft_max_word_len的词语，都不会被索引。 适用场景 非事务型应用（数据仓库，报表，日志数据） 只读类应用 空间类应用（空间函数，坐标） 1.3 InnoDB存储引擎在MySQL 5.5以及以后版本，InnoDB是默认存储引擎。 存储InnoDB的数据存储在表空间。表空间 独立表空间（tablename.ibd） 可以通过optimize table 收缩系统文件 可以同时向多个文件刷新数据 系统表空间（ibdataX） 无法简单的收缩文件大小 会产生IO瓶颈 表空间相关参数：innodb_file_per_table。 值 含义 ON 使用独立表空间 OFF 使用系统表空间 特性 Innodb是一种事务性存储引擎 完全支持事物的ACID特性 Redo Log和Undo Log Innodb支持行级锁（并发程度更高）和表级锁。 适用场景Innodb适合大多数OLTP应用。 1.4 MyISAM和InnoDB的区别 项目 MyISAM InnoDB 锁级别 表级锁(table-level locking) 行级锁(row-level locking)和表级锁,默认为行级锁 事务 MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。 InnoDB提供事务支持事务，外部键等高级数据库功能。 外键 不支持 支持 MVCC 不支持 支持 1.5 MVCC(Multiversion concurrency control)MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提高并发性能的考虑，他们一般都同时实现了多版本并发控制(MVCC)。可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC的实现有乐观并发控制和悲观并发控制。MVCC的实现，是通过保存数据在某个时间点的快照来实现的。InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是REPEATABLE READ(可重复读)，并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 Next-Key locking 是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。InnoDB自动使用间隙锁的条件： 必须在Repeatable Read级别下 检索条件必须有索引 相关概念 read viewread view 主要是用来做可见性判断的，比较普遍的解释便是”本事务不可见的当前其他活跃事务”。对于read view快照的生成时机，也非常关键，正是因为生成时机的不同，造成了RC,RR两种隔离级别的不同可见性。 在InnoDB中(默认repeatable read级别)，事务在begin/start transaction之后的第一条select读操作后，会创建一个快照(read view)， 将当前系统中活跃的其他事务记录记录起来; 在InnoDB中(默认repeatable committed级别)，事务中每条select语句都会创建一个快照(read view); undo-log Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。 Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。 大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo。 另外，在回滚段中的undo logs分为：insert undo log 和 update undo log insert undo log : 事务对insert新记录时产生的undolog，只在事务回滚时需要，并且在事务提交后就可以立即丢弃。 update undo log : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 InnoDB存储引擎在数据库每行数据的后面添加了三个字段 6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符，即最后一次修改(insert|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted，并非真正删除。 7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新，则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。 6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID，当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。 简单的事务流程图示 InnoDB中的读操作在InnoDB中的操作可以分为当前读(current read)和快照读(snapshot read)。 快照读(snapshot read) 简单的select操作(当然不包括 select … lock in share mode，select … for update)。 当前读(current read) select … lock in share mode select … for update insert update delete 在RR级别下，快照读是通过MVCC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。InnoDB在快照读的情况下并没有真正的避免幻读，但是在当前读的情况下避免了不可重复读和幻读。 MVCC的特点一般我们认为MVCC有下面几个特点： 每行数据都存在一个版本，每次数据更新时都更新该版本。 修改时Copy出当前版本，然后随意修改，各个事务之间无干扰。 保存时比较版本号，如果成功(commit)，则覆盖原记录，失败则放弃copy(rollback)。 就是每行都有版本号，保存时根据版本号决定是否成功。 InnoDB对MVCC的实现 事务以排他锁的形式修改原始数据 把修改前的数据存放于undo log，通过回滚指针与主数据关联。 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）。 InnoDB中的MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://linzai745.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linzai745.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"https://linzai745.github.io/tags/DB/"}]},{"title":"MySQL-逻辑架构","slug":"mysql/logic_architecture/logic_architecture","date":"2020-07-05T08:38:39.000Z","updated":"2021-03-05T13:41:26.216Z","comments":true,"path":"2020/07/05/mysql/logic-architecture/logic-architecture/","link":"","permalink":"https://linzai745.github.io/2020/07/05/mysql/logic-architecture/logic-architecture/","excerpt":"","text":"1 逻辑架构MySQL的逻辑系统架构包括：连接层、SQL处理层和存储引擎层。 1.1 连接层 创建连接当MySQL启动（MySQL服务器就是一个进程），等待客户端连接，每一个客户端连接请求，服务器都会新建一个线程处理（如果是线程池的话，则是分配一个空的线程），每个线程都是独立的，拥有各自的内存处理空间，但是，如果这个请求只是查询，没关系，但是若是修改数据，很显然，当两个线程修改同一块内存是会引发数据同步问题的。 鉴权校验客户端连接到服务器后，服务器需要对其进行验证，也就是用户名、IP、密码验证，一旦连接成功，还要验证是否具有执行某个特定查询的权限（例如，是否允许客户端对某个数据库某个表的某个操作）。 1.2 SQL处理层这一层的主要功能：SQL语句的解析、SQL语句优化、缓存查询、MySQL内置函数的实现和跨存储引擎功能。 所谓跨存储引擎就是说每个引擎都需要提供的功能，也就是引擎需要对外提供接口。例如：存储过程、触发器、视图等。 处理流程： 如果是select语句，首先会查询缓存是否已有相应结果，有则返回结果，没有则进行下一步。如果不是select语句，同样执行到下一步。 解析查询，创建一个内部数据结构（解析树），这个解析树主要用来做SQL语句语义和语法解析。 优化，优化SQL语句，例如重写查询，决定表的读取顺序，以及选择需要的索引等。这一阶段用户是可以查询的，查询服务器优化器是如何进行优化的，便于用户重构查询和修改相关配置，达到最优化。这一阶段还涉及到存储引擎，优化器会询问存储引擎，比如某个操作的开销信息、是否对待特定索引有查询优化等。 1.2.1 查询缓存执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。缓存的对象包括SQL语句、SQL执行计划、数据。开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。 缓存建⽴之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发⽣变 化，那么和这张表相关的所有缓存数据都将失效。 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做⼀次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应⽤来说更是如此。如果开启，要注意合理控制缓存空间⼤⼩，⼀般来说其⼤⼩设置为⼏⼗MB⽐较合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存。 select sql_no_cache count(*) from table; 开启查询缓存的方式 方式一：my.cnf加入一下配置，重启MySQL开启查询缓存。query_cache_type=1 query_cache_size=600000 方式二：MySQL执行以下命令开启查询缓存。set global query_cache_type=1 set global query_cache_size=600000 1.2.2 解析查询SQL语句结构 SELECT DISTINCT < select_list> FROM < left_table> < join_type > JOIN < right_table > ON < join_condition > WHERE < where_condition > GROUP BY < group_by_list > HAVING < having_condition > ORDER BY < order_by_condition > LIMIT < limit_number > SQL解析流程 1.2.3 优化器当我们编写Sql语句执行时，优化器会觉得我写的sql语句性能不够好，这个时候，优化器会自己写一个等价于跟我写的执行后结果一致的sql语句进行代替。 1.3 存储引擎层MySQL中常用的存储引擎： MyISAM InnoDB CSV Memory Archive Ferderated 查看MySQL所有支持的存储引擎的指令： show engines;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://linzai745.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linzai745.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"https://linzai745.github.io/tags/DB/"}]},{"title":"JVM的执行子系统","slug":"jvm/subsystem/subsystem","date":"2020-06-26T07:03:24.000Z","updated":"2021-03-04T03:08:44.035Z","comments":true,"path":"2020/06/26/jvm/subsystem/subsystem/","link":"","permalink":"https://linzai745.github.io/2020/06/26/jvm/subsystem/subsystem/","excerpt":"","text":"1 类文件结构1.1 Java跨平台的基础各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，也是语言无关性的基础。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。 1.2 Class类的本质任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上并不一定以磁盘文件的形式存在。Class文件是一个以8位字节为基础的二进制流。 1.3 Class文件格式各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。Class文件格式采用一种类似于c语言结构体的伪结构类存储数据，这种伪结构中只有两种数据类型：无符号数和表。 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以_info结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。ClassFile { u4 magic; //Class 文件的标志 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口数量 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//Class 文件的字段属性数量 field_info fields[fields_count];//一个类会可以有个字段 u2 methods_count;//Class 文件的方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 } Class文件字节码结构组织示意图 Class文件格式详解 魔数 每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。 Class文件版本 Class 文件的版本号,保证编译正常执行。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。 常量池 常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。 字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。 而符号引用则属于编译原理方面的概念，包括了下面三类常量：类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。 访问标志 用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。 类索引 类索引用于确定这个类的全限定名 父类索引 父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。 接口索引集合 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。 字段表集合 描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 类级变量：静态变量，static修饰实例级变量：成员变量 方法表集合 描述了方法的定义，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器&lt;clinit&gt;方法和实例构造器&lt;init&gt; 属性表集合 存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。 2 字节码指令Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条。 tips:大多数的指令都包含了其操作所对应的数据类型信息。例如：iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。 2.1 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。 作用 指令 将一个局部变量加载到操作栈 iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt; 将一个数值从操作数栈存储到局部变量表 istore、store_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt; 将一个常量加载到操作数栈 bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt; 扩充局部变量表的访问索引的指令 wide 2.2 运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 作用 指令 加法指令 iadd、ladd、fadd、dadd 减法指令 isub、lsub、fsub、dsub 乘法指令 imul、lmul、fmul、dmul 2.3 类型转换指令可以将两种不同的数值类型进行相互转换。Java虚拟机直接支持以下数值类型的宽化类型转换（即小范围类型向大范围类型的安全转换）： int类型到long、float或者double类型 long类型到float、double类型 float类型到double类型 处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成。这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。 2.4 创建类实例和数组的指令 作用 指令 创建类实例 new 创建数组 newarray、anewarray、multianewarray 2.5 访问字段指令getfield、putfield、getstatic、putstatic 2.6 数组存取相关指令 作用 指令 把一个数组元素加载到操作数栈的指令 baload、caload、saload、iaload、laload、faload、daload、aaload 将一个操作数栈的值存储到数组元素中的指令 bastore、castore、sastore、iastore、fastore、dastore、aastore 取数组长度的指令 arraylength 2.7 检查类实例类型的指令instanceof、checkcast。 2.8 操作数栈管理指令如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令。 作用 指令 将操作数栈的栈顶一个或两个元素出栈 pop、pop2 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶 dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2 将栈最顶端的两个数值互换 swap 2.9 控制转移指令控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。 作用 指令 条件分支 ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne 复合条件分支 tableswitch、lookupswitch 无条件分支 goto、goto_w、jsr、jsr_w、ret 2.10 方法调用指令 指令 作用 invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。 invokeinterface 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。 invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。 invokestatic 指令用于调用类方法（static方法）。 invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 tips: 方法调用指令与数据类型无关。 2.11 方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。 2.12 异常处理指令在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现。 2.13 同步指令有monitorenter和monitorexit两条指令来支持synchronized关键字的语义。 3 类加载机制3.1 类加载过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（initialization） 使用（Using） 卸载（Unloading） 其中验证、准备、解析这三个部分统称为连接（Linking）。 加载阶段这一阶段虚拟机主要完成一下三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass()方法）。数组类型不通过类加载器创建,它由Java虚拟机直接创建。 验证阶段是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：public static int value=123；那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器&lt;clinit&gt;()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。假设上面类变量value的定义变为：public static final int value=123；编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。&lt;clinit&gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个进程阻塞。 在初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）： 遇到new, getstatic, putstatic, invokestatic这四种字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成四条指令的最常见的Java代码场景是： 使用new关键字实例化对象的时候 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 调用一个类的静态方法 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 Tips: 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。对于常量（static final修饰），其实在编译阶段通过常量传播优化，已经将此常量的值存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLO_WORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。 3.2 类加载器3.2.1 自定义类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。在自定义ClassLoader的子类时候，我们常见的会有两种做法。 一种是重写loadClass()方法。 另一种是重写findClass()方法。 其实这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。我建议的做法是只在findClass()里重写自定义类的加载方法。loadClass()这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。 3.2.2 系统的类加载器从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 加载器类型 描述 启动类加载器（Bootstrap ClassLoader） 这个类将器负责将存放在&lt;JAVA_HOME&gt;\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。 扩展类加载器（Extension ClassLoader） 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader） 这个类加载器由sun.misc.Launcher$App-ClassLoade实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 3.2.3 双亲委派模型 双亲委派模型描述每一个类都有一个对应它的类加载器。系统中的 ClassLoader在协同工作的时候会默认使用双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass()处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器BootstrapClassLoader作为父类加载器。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 双亲委派模型实现源码分析 protected Class&lt;?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先检查请求的类是否已经被加载 Class&lt;?> c = findLoadedClass(name); if (c == null) { //请求的类未被加载 long t0 = System.nanoTime(); try { if (parent != null) { // 调用父类加载器的loadClass方法加载 c = parent.loadClass(name, false); } else { // JVM规范明确的说明，只有启动类加载器的父类加载器为空。 // 这里调用启动类加载器BootstrapClassLoader加载 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // 自己尝试加载 long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 双亲委派模型带来的好处双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果不用没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object类的话，那么程序运行的时候，系统就会出现多个不同的Object 类。 破坏双亲委派模型为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载loadClass()即可。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linzai745.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/tags/JVM/"}]},{"title":"红黑树","slug":"datastructure/rbt/red-black-tree","date":"2020-06-25T13:44:01.000Z","updated":"2021-02-24T13:45:17.289Z","comments":true,"path":"2020/06/25/datastructure/rbt/red-black-tree/","link":"","permalink":"https://linzai745.github.io/2020/06/25/datastructure/rbt/red-black-tree/","excerpt":"","text":"","categories":[{"name":"数据结构&算法","slug":"数据结构-算法","permalink":"https://linzai745.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://linzai745.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://linzai745.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"垃圾收集以及内存分配策略","slug":"jvm/gc/gc_and_memory_allocate","date":"2020-06-24T03:20:47.000Z","updated":"2021-03-05T07:24:20.800Z","comments":true,"path":"2020/06/24/jvm/gc/gc-and-memory-allocate/","link":"","permalink":"https://linzai745.github.io/2020/06/24/jvm/gc/gc-and-memory-allocate/","excerpt":"","text":"1 对象、引用以及垃圾回收算法1.1 对象存活的判定方法1.1.1 引用计数法 算法思想：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1。当引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。 优点：快、方便、实现简单。 缺点：对象相互引用时，很难判断对象是否该回收。 1.1.2 可达性分析 算法思想：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 GC Roots的对象包括下面几种 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量应用对象 本地方法栈中JNI(即一般说的Native方法)引用的对象 1.2 引用类型 强引用一般的Object obj = new Object()，就属于强引用。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 软引用(SoftReference)一些有用但是并非必需，用软引用关联的对象，系统将在要发生OOM之前，这些对象就会被收回。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 public static void main(String[] args) { User u = new User(1, \"user1\"); SoftReference&lt;User> userSoft = new SoftReference&lt;>(u); u = null; //保证new User(1, \"user1\")这个实例只有userSoft在软引用 System.out.println(userSoft.get()); System.gc(); //展示gc的时候，SoftReference不一定会被回收 System.out.println(\"AfterGC\"); System.out.println(userSoft.get()); //new User(1, \"user1\")没有被回收 List&lt;byte[]> list = new LinkedList&lt;>(); try { for (int i = 0; i &lt; 100; i++) { //User(1, \"user1\")实例一直存在 System.out.println(userSoft.get()); list.add(new byte[1024 * 1024]); } } catch (Throwable e) { //抛出OOM异常后打印的，User(1, \"Mark\")这个实例被回收 System.out.println(\"Throwable: \" + userSoft.get()); } } 弱引用(WeakReference)一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 public static void main(String[] args) { User u = new User(1, \"user1\"); WeakReference&lt;User> userWeak = new WeakReference&lt;>(u); u = null; System.out.println(userWeak.get()); System.gc(); System.out.println(\"AfterGc\"); System.out.println(userWeak.get()); } 虚引用(PhantomReference)“虚引用”顾名思义,就是形同虚设,与其他几种引用都不同,虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时,如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列,那么就可以在所引用的对象的内存被回收之前采取必要的行动。特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。 幽灵引用最弱，被垃圾回收的时候收到一个通知 Tips：软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放。例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。 1.3 垃圾收集算法1.3.1 标记-清除算法（Mark-Sweep） 算法思想：算法分为“标记”和“清除”阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 缺点：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 1.3.2 复制算法（Copying） 算法思想：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。 缺点：这种算法的代价是将内存缩小为了原来的一半。 1.3.3 标记-整理算法（Mark-Compact） 算法思想：根据老年代的特点特出的一种标记算法，首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 1.3.4 分代收集算法 算法思想：根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 2 垃圾回收器垃圾回收器列表 收集器 收集对象和算法 收集器类型 说明 适用场景 Serial 新生代，复制算法 单线程 进行垃圾收集时，必须暂停所有工作线程，直到完成；(stop the world) 简单高效；适合内存不大的情况； ParNew 新生代，复制算法 并行的多线程收集器 ParNew垃圾收集器是Serial收集器的多线程版本 搭配CMS垃圾回收器的首选 Parallel Scavenge 新生代，复制算法 并行的多线程收集器 类似ParNew,更加关注吞吐量，达到一个可控制的吞吐量； 本身是Server级别多CPU机器上的默认GC方式，主要适合后台运算不需要太多交互的任务； Serial Old 老年代，标记整理算法 单线程 jdk7/8默认的老生代垃圾回收器 Client模式下虚拟机使用 Parallel Old 老年代，标记整理算法 并行的多线程收集器 Parallel Scavenge收集 器的老年代版本，为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合； 在注重吞吐量以及CPU资源敏感的场合采用 CMS 老年代，标记清除算法 并行与并发收集器 尽可能的缩短垃圾收集时 用户线程停止时间；缺点在于： 1.内存碎片。 2.需要更多cpu资源。 3.浮动垃圾问题，需要更大的堆空间。 重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器; G1 跨新生代和老年代；标记整理+化整为零 并行与并发收集器 JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势； 面向服务端应用的垃圾回收器，目标为取代CMS 2.1 Serial收集器Serial(串行)收集器收集器是最基本，历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World”)，直到它收集结束。收集对象和算法：新生代，采用复制算法。优点：它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。配置参数：-XX:+UseSerialGC 新生代和老年代都用串行收集器。 2.2 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。收集对象和算法：新生代，复制算法。优点：多线程，多CPU的，停顿时间比Serial少。参数：-XX:+UseParNewGC 新生代使用ParNew收集器，老年代使用Serial Old收集器。 并行和并发概念补充 并行（Parallel）：指多条垃圾收集线程并行工作,但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行,可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。 2.3 Parallel Scavenge（ParallerGC）收集器Parallel Scavenge收集器类似于 ParNew 收集器。Parallel Scavenge收集器关注点是吞吐量(高效率的利用CPU)，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间(提高用户体验)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。收集对象和算法：新生代，采用复制算法。相关参数： 参数 描述 -XX:+UseParallelOldGC 新生代使用ParallerGC,老年代使用Parallel Old -XX:MaxGCPauseMills 参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费地时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300M新生代肯定比收集500M快吧，这也直接导致垃圾收集发生得更加频繁一些，原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。 -XX:GCTimeRatio 参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的5%(即1/(1+19))，默认值为99，就是允许最大1%(即1/(1+99))的垃圾收集时间。 -XX:+UseAdaptiveSizePolicy 当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)，Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态的调用这些参数以提供这些参数合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略。 如果对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。 2.4 Serial Old收集器Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。收集对象和算法：老年代，标记-整理算法。相关参数： 参数 描述 -XX:+UseSerialGC 新生代和老年代都用串行收集器。 -XX:+UseParNewGC 新生代使用ParNew收集器，老年代使用Serial Old收集器。 -XX:+UseParallelGC 新生代使用ParallerGC收集器，老年代使用Serial Old收集器。 2.5 Parallel Old收集器Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。收集对象和算法：老年代，标记-整理算法。参数: XX:+UseParallelOldGC: 新生代使用ParallerGC收集器，老年代使用Parallel Old收集器。 2.6 CMS收集器CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤: 初始标记：暂停所有的其他线程,并记录下直接与GC Roots相连的对象，速度很快; 并发标记：和用户的应用程序同时进行，进行GC RootsTracing的过程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍⻓，远远比并发标记阶段时间短。 并发清除：开启用户线程，同时GC线程开始对为标记的区域做清扫。 收集对象和算法：老年代，采用标记-清除算法。相关参数： 参数 描述 -XX:CMSInitialOccupyFraction CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。 -XX:+UseCMSCompactAtFullCollection CMS收集器提供了一个这个开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。 -XX:CMSFullGCsBeforeCompaction 这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入FullGC时都进行碎片整理 优点：并发收集、低停顿缺点：对CPU资源敏感，无法处理浮动垃圾，它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。 2.7 G1收集器G1(Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。G1收集器对堆的内存布局：被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点: 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 内存布局：在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 新生代GC过程：回收Eden区和survivor区，回收后，所有eden区被清空，存在一个survivor区保存了部分数据。老年代区域会增多，因为部分新生代的对象会晋升到老年代。并发标记周期： 初始标记：短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，产生一个全局停顿，都伴随有一次新生代的GC。 根区域扫描：扫描survivor区可以直接到达的老年代区域。 并发标记阶段：扫描和查找整个堆的存活对象，并标记。 重新标记：会产生全局停顿，对并发标记阶段的结果进行修正。 独占清理：会产生全局停顿，对GC回收比例进行排序，供混合收集阶段使用。 并发清理：识别并清理完全空闲的区域，并发进行。 混合收集：对含有垃圾比例较高的Region进行回收。 参数 描述 -XX:+UseG1GC 开启使用G1收集器 -XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。 -XX:ParallerGCThreads 设置GC的工作线程数量 3 内存分配策略堆空间的基本结构： 上图所示的 eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加1，当它的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。内存分配策略 对象优先在Eden分配如果说Eden内存空间不足，就会发生Minor GC。 大对象直接进入老年代大对象：需要大量连续的内存空间的Java对象，比如很长的字符串和大型数组。 导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们。 会进行大量的内存复制。 -XX:PretenureSizeThreshold 参数，大于这个数量直接在老年代分配，缺省为0，表示绝不会直接分配在老年代。 长期存活的对象将进入老年代默认15岁，-XX:MaxTenuringThreshold调整。 动态对象年龄判定：为了能更好地适应不同程序的内存状况，虚拟机并永远地要求对象地年龄必须达到了MaxTenuringThreshold才能晋升老年代，但如果在Survivor空间相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则进行Full GC。 Tips!大多数情况下，对象在新生代中eden区分配。当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。新生代GC(Minor GC)：指发生新生代的的垃圾收集动作,Minor GC非常频繁,回收速度一般也比较快。老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC(并非绝对)，Major GC的速度一般会比Minor GC的慢10倍以上。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linzai745.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/tags/JVM/"}]},{"title":"二叉搜索树","slug":"datastructure/bst/binary-search-tree","date":"2020-06-22T13:32:44.000Z","updated":"2021-02-24T13:37:54.453Z","comments":true,"path":"2020/06/22/datastructure/bst/binary-search-tree/","link":"","permalink":"https://linzai745.github.io/2020/06/22/datastructure/bst/binary-search-tree/","excerpt":"","text":"","categories":[{"name":"数据结构&算法","slug":"数据结构-算法","permalink":"https://linzai745.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://linzai745.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://linzai745.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JVM运行时数据区域","slug":"jvm/runtimeDataArea/runtimeDataArea","date":"2020-06-22T01:33:12.000Z","updated":"2021-03-04T03:14:39.441Z","comments":true,"path":"2020/06/22/jvm/runtimedataarea/runtimedataarea/","link":"","permalink":"https://linzai745.github.io/2020/06/22/jvm/runtimedataarea/runtimedataarea/","excerpt":"","text":"1 JVM运行时数据区域 1.1 PC程序计数器 当前线程执行的字节码的行号指示器，占用空间小，也无法干涉。 个线程之间独立存储，互不影响。 程序计数器的实际作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码控制流程。如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到的位置。 tips: 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 1.2 虚拟机栈（JVM Stack） 每个线程私有（JVM会为每个线程都分配一个JVM栈） 线程在运行时，在执行的每个方法都会打包成一个栈帧-存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。 每个时刻正在执行的当前方法就是虚拟机栈栈顶的栈帧，方法执行结束后，这个栈帧就会被弹出栈。 方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 -Xss调整大小，例如-Xss256k。 tips：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 1.3 堆（Heap） 几乎所有的对象都分配在这里，也是垃圾回收发生的主要区域（因此也称为GC堆） 细分为新生代和老年代，再细致一点有：Eden空间、From Survivor、To Survivor空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。 堆内存的相关调整参数： 参数 说明 -Xms 堆的最小值 -Xmx 堆的最大值 -Xmn 新生代的大小 -XX:NewSize 新生代最小值 -XX:MaxNewSize 新生代最大值 例如：-Xmx256m 堆空间结构 eden区，s0区，s1区都属于新生代。tentired区属于老年代。 对象晋升：大部分情况下，对象都会首先在Eden区分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0或者s1，并且对象的年龄会加1（Eden区迁移到Survivor区后对象的初始年龄变为1），当它的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中。对象晋升到老年代的年龄阈值,可以通过参数 -XX:MaxTenuringThreshold来设置。 1.3 方法区/永久代（Method Area） 用于存储已经被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码。 方法区的相关调整参数： 版本 参数 JDK1.7以前 -XX:PermSize; -XX:MaxPermSize JDK1.8以后 -XX:MetaspaceSize; -XX:MaxMetaspaceSize tips：JDK1.8以后大小就只受本机总内存的限制。示例：-XX:MaxMetaspaceSize=3M。Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 为什么去永久代：整个永久代有一个JVM本身设置固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 -XX:MaxMetaspaceSize标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX:MetaspaceSize调整标志定义元空间的初始大小如果未指定此标志，则Metaspace将根据运行时的应用程序需求动态地重新调整大小。 1.3.1 运行时常量池在JDK1.6中，运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量(“zdy” , “123”等)和符号引用。 1.4 直接内存 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 如果使用了NIO，这块区域会被频繁使用，在Java堆内可以用DirectByteBuffer对象直接引用并操作。 这块内存不受Java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。 1.5 各版本内存区域的变化 JDK 1.6中运行时常量池是属于方法区的。 JDK 1.7中将运行时常量池移动到了堆中。 JDK 1.8中使用元空间代替了方法区。 tips：永久代用来存储类信息、常量、静态变量等数据不是个好主意，很容易遇到内存溢出的问题。对永久代进行调优是很困难的，同时将元空间与堆的垃圾回收进行隔离，避免永久代引发的Full GC 和 OOM等问题。同时所有的线程私有的内存区域都是在编译时确定所需的内存大小。 1.6 深入辨析堆和栈 功能 栈内存是以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量(int、short、long、byte、float、double、boolean、char等)以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放。 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 线程独享还是共享 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。 堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 空间大小 栈的内存要远远小于堆内存 1.7 栈帧结构与方法出入栈 方法会打包成栈帧，一个栈帧至少要包含局部变量表，操作数栈和帧数据区 堆、栈、方法区的联系 1.8 栈上分配 虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不是分配在堆上。 好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。 栈上分配需要的技术基础，逃逸分析，标量替换。 逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。 1.9 栈上分配的启用 -server（JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client） -Xmx10m和-Xms10m（堆的大小） -XX:+DoEscapeAnalysis（启用逃逸分析[默认打开]） -XX:+PrintGC（打印GC日志） -XX:+EliminateAllocations（标量替换[默认打开]） -XX:-UseTLAB（关闭本地线程分配缓冲，TLAB：ThreadLocalAllocBuffer） 对栈上分配发生影响的参数就是三个，-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations，任何一个发生变化都不会发生栈上分配，因为启用逃逸分析和标量替换默认是打开的，所以，在我们的例子中，JVM的参数只用-server一样可以有栈上分配的效果。 2 虚拟机中的对象2.1 对象的创建 检查加载 先执行相应的类加载过程。 内存分配 虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。内存分配的方法： 指针碰撞：如果Java堆内存中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。 tips: 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 并发安全问题：除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。并发安全问题的两种解决方案 CAS + 失败重试：这是一种对分配内存空间的动作进行同步处理的方式，CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试,直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB：这种是把内存分配的动作按照线程划分在不同的空间之中进行，为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），即每个线程在Java堆中预先分配一小块私有内存。如果设置了虚拟机参数-XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。 内存空间初始化 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。 对象初始化 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 2.2 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。 2.3 对象的访问定位建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 如果使用直接指针访问， reference中存储的直接就是对象地址。 tips: 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linzai745.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/tags/JVM/"}]},{"title":"哈希表","slug":"datastructure/hash/hashtable","date":"2020-06-20T13:25:08.000Z","updated":"2021-02-24T13:29:11.697Z","comments":true,"path":"2020/06/20/datastructure/hash/hashtable/","link":"","permalink":"https://linzai745.github.io/2020/06/20/datastructure/hash/hashtable/","excerpt":"","text":"","categories":[{"name":"数据结构&算法","slug":"数据结构-算法","permalink":"https://linzai745.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://linzai745.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://linzai745.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"链表","slug":"datastructure/linkedlist/linkedlist","date":"2020-06-17T09:24:20.000Z","updated":"2021-02-24T13:00:45.634Z","comments":true,"path":"2020/06/17/datastructure/linkedlist/linkedlist/","link":"","permalink":"https://linzai745.github.io/2020/06/17/datastructure/linkedlist/linkedlist/","excerpt":"","text":"链表","categories":[{"name":"数据结构&算法","slug":"数据结构-算法","permalink":"https://linzai745.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://linzai745.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://linzai745.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数组","slug":"array","date":"2020-06-15T08:59:33.000Z","updated":"2021-02-24T06:28:28.007Z","comments":true,"path":"2020/06/15/array/","link":"","permalink":"https://linzai745.github.io/2020/06/15/array/","excerpt":"","text":"数组(Array)创建形式Java，C++ int a[100]; int[] a = new int[100]; Python list = [] JavaScript let x = [1, 2, 3] 数组底层原理数组的底层机器层面的实现，是通过内存管理器为数组分配内存空间，而且分配的内存是一块连续的内存。每个地址可以通过内存管理器直接进行访问。 操作数组可以随机访问任意元素，并且访问操作的时间复杂度是O(1)级别。但是增加和删除操作就没有这么的高效。下面我们来看看增加和删除的操作过程。 增加元素 可见数组在将元素插入到数组时需要将数组内的元素进行相应的移动，所以在数组中将元素插入到数组的时间复制度是O(n)级别。 删除元素 数组在删除某个元素时，同样的在删除元素后也需要将相应的元素进行移动，所以在数组中删除元素的时间复制度是O(n)级别。 时间复杂度 操作 时间复杂度 prepend O(1) append O(1) lookup O(1) insert O(n) delete O(n) ArrayList源码分析在Java中ArrayList是对array的一个封装，作用就相当于一个动态数组，它的容量能动态增长，在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 ArrayList类结构public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始化容量. */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空实例的共享空数组. */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 共享的空数组实例，用于默认大小的空实例。 * 我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 保存ArrayList数据的数组，任意为elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的数组 * 都会在添加第一个元素后将容量扩展为DEFAULT_CAPACITY。 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList实际所包含的元素数量. * @serial */ private int size; public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } } 源码的注解中提到，每当ArrayList添加第一个元素后，elementData[]会扩容到默认值。为了验证这一说法，给出下面的代码进行验证。 public class ArrayListCapacityTest { private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; private int size; Object[] elementData; public ArrayListCapacityTest() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public boolean add(Integer e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } public int elementDataLength() { if (elementData == null) return -1; return elementData.length; } private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { // modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } public static void main(String[] args) { ArrayListCapacityTest list = new ArrayListCapacityTest(); System.out.println(\"Before the first element added. the elementData[] length is: \" + list.elementDataLength()); list.add(1); System.out.println(\"After the first element added. the elementData[] length is: \" + list.elementDataLength()); } } console输出： Before the first element added. the elementData[] length is: 0 After the first element added. the elementData[] length is: 10在代码调用list.add(1)，我们打印输出了一次elementData数组的length，可以看出来初始化是这个数组是一个空数组。在我们添加第一个元素后，数组的length已经变为10，也就说明了一个空的ArrayList在添加第一个元素后都会进行一次扩容，并且扩容为默认值。 ArrayList常用方法添加元素 - add(E e) /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt>true&lt;/tt> (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 这个方法将元素追加到list的尾部，每次追加都会保证数组的容量为size + 1。 添加元素到指定位置 - add(int index, E element) /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); //校验边界 ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 这个方法需要对数组中的元素进行移动。 移除指定位置的元素 - remove(int index) /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { rangeCheck(index); //检验边界 modCount++; E oldValue = elementData(index); //拿到index位置的值 int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //将index后面的元素往前移动一位 elementData[--size] = null; // clear to let GC do its work return oldValue; //返回index位置的值 } 移除指定元素 - remove(Object o)/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt>i&lt;/tt> such that * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt> * (if such an element exists). Returns &lt;tt>true&lt;/tt> if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt>true&lt;/tt> if this list contained the specified element */ public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } 这个方法会将第一次找到的指定元素移除，而不会将所有的指定元素移除。 替换指定位置的元素 - set(int index, E element) /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException {@inheritDoc} */ public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } 替换index位置的值，并将旧值返回。 扩容策略前面已经介绍了ArrayList在每次添加元素的时候都会检查保证数组的容量为size+1，下面我们来看看ArrayList的扩容机制。下面的分析都是建立在ArrayList使用无参构造创建的基础上。 首先，我们先来看看add(E e)方法，这个方法先调用了ensureCapacityInternal(size + 1)。 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } ensureCapacityInternal()方法，先调用calculateCapacity()方法拿到最小扩容量。再将最小扩容量传递给ensureExplicitCapacity()方法。 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } calculateCapacity()方法，这个方法返回DEFAULT_CAPACITY和minCapacity之中的较大值。 注意：前提我们已经说过，我们的分析是使用ArrayList的无参构造创建的list. private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } ensureExplicitCapacity()方法，这个方法会根据minCapacity与elementData.length的比较，判断elementData[]数组是否需要扩容。 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } grow()方法，将elementData[]数组的容量扩大原数组容量的一半， private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; /** * 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， * 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`， * 否则，新容量大小则为 MAX_ARRAY_SIZE 即为`Integer.MAX_VALUE - 8`。 */ if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } hugeCapacity()方法，在grow方法中，当newCapacity超过MAX_ARRAY_SIZE，会调用hugeCapacity()方法，如果minCapacity超过MAX_ARRAY_SIZE，容量将会扩容为Integer.MAX_VALUE。否则为MAX_ARRAY_SIZE。 private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 不管用户创建ArrayList时是否指明容量大小，这个机制的触发总是在你需要的空间大于elementData数组现有的空间时触发。特殊的，用户使用无参构造器，当你添加第一个元素时，此时elementData.length为0，小于用户所需要的空间，所有这时需要进行一次扩容，而这次扩容是将容量扩容为一个默认值10。下一次扩容将会在用户需要的空间大于10时触发，将会扩容为10 + 10 / 2 = 15。下次扩容的触发以此类推。即使用户指定初始化的容器容量，扩容机制的触发仍然是在ArrayList没有足够的空间时触发。 ArrayList总结 ArrayList不能够保证线程安全。 底层的数据结构为数组，这样使ArrayList可以支持快速的随机访问。 在插入和删除元素时，需要对数组中的数据进行移动。","categories":[{"name":"数据结构&算法","slug":"数据结构-算法","permalink":"https://linzai745.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://linzai745.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://linzai745.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://linzai745.github.io/categories/MySQL/"},{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/categories/JVM/"},{"name":"数据结构&算法","slug":"数据结构-算法","permalink":"https://linzai745.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linzai745.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"https://linzai745.github.io/tags/DB/"},{"name":"Java","slug":"Java","permalink":"https://linzai745.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://linzai745.github.io/tags/JVM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://linzai745.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://linzai745.github.io/tags/%E7%AE%97%E6%B3%95/"}]}